{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends, __spreadArrays } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, Classes, Keys, Utils } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { Icon } from \"../icon/icon\";\nimport { Tag } from \"../tag/tag\";\n/** special value for absence of active tag */\n\nvar NONE = -1;\n\nvar TagInput =\n/** @class */\nfunction (_super) {\n  __extends(TagInput, _super);\n\n  function TagInput() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      activeIndex: NONE,\n      inputValue: _this.props.inputValue || \"\",\n      isInputFocused: false\n    };\n    _this.refHandlers = {\n      input: function (ref) {\n        _this.inputElement = ref;\n        Utils.safeInvoke(_this.props.inputRef, ref);\n      }\n    };\n\n    _this.addTags = function (value, method) {\n      if (method === void 0) {\n        method = \"default\";\n      }\n\n      var _a = _this.props,\n          inputValue = _a.inputValue,\n          onAdd = _a.onAdd,\n          onChange = _a.onChange,\n          values = _a.values;\n\n      var newValues = _this.getValues(value);\n\n      var shouldClearInput = Utils.safeInvoke(onAdd, newValues, method) !== false && inputValue === undefined; // avoid a potentially expensive computation if this prop is omitted\n\n      if (Utils.isFunction(onChange)) {\n        shouldClearInput = onChange(__spreadArrays(values, newValues)) !== false && shouldClearInput;\n      } // only explicit return false cancels text clearing\n\n\n      if (shouldClearInput) {\n        _this.setState({\n          inputValue: \"\"\n        });\n      }\n    };\n\n    _this.maybeRenderTag = function (tag, index) {\n      if (!tag) {\n        return null;\n      }\n\n      var _a = _this.props,\n          large = _a.large,\n          tagProps = _a.tagProps;\n      var props = Utils.isFunction(tagProps) ? tagProps(tag, index) : tagProps;\n      return React.createElement(Tag, __assign({\n        active: index === _this.state.activeIndex,\n        \"data-tag-index\": index,\n        key: tag + \"__\" + index,\n        large: large,\n        onRemove: _this.props.disabled ? null : _this.handleRemoveTag\n      }, props), tag);\n    };\n\n    _this.handleContainerClick = function () {\n      if (_this.inputElement != null) {\n        _this.inputElement.focus();\n      }\n    };\n\n    _this.handleContainerBlur = function (_a) {\n      var currentTarget = _a.currentTarget;\n      requestAnimationFrame(function () {\n        // we only care if the blur event is leaving the container.\n        // defer this check using rAF so activeElement will have updated.\n        if (!currentTarget.contains(document.activeElement)) {\n          if (_this.props.addOnBlur && _this.state.inputValue !== undefined && _this.state.inputValue.length > 0) {\n            _this.addTags(_this.state.inputValue, \"blur\");\n          }\n\n          _this.setState({\n            activeIndex: NONE,\n            isInputFocused: false\n          });\n        }\n      });\n    };\n\n    _this.handleInputFocus = function (event) {\n      _this.setState({\n        isInputFocused: true\n      });\n\n      Utils.safeInvoke(_this.props.inputProps.onFocus, event);\n    };\n\n    _this.handleInputChange = function (event) {\n      _this.setState({\n        activeIndex: NONE,\n        inputValue: event.currentTarget.value\n      });\n\n      Utils.safeInvoke(_this.props.onInputChange, event);\n      Utils.safeInvoke(_this.props.inputProps.onChange, event);\n    };\n\n    _this.handleInputKeyDown = function (event) {\n      var _a = event.currentTarget,\n          selectionEnd = _a.selectionEnd,\n          value = _a.value;\n      var activeIndex = _this.state.activeIndex;\n      var activeIndexToEmit = activeIndex;\n\n      if (event.which === Keys.ENTER && value.length > 0) {\n        _this.addTags(value, \"default\");\n      } else if (selectionEnd === 0 && _this.props.values.length > 0) {\n        // cursor at beginning of input allows interaction with tags.\n        // use selectionEnd to verify cursor position and no text selection.\n        if (event.which === Keys.ARROW_LEFT || event.which === Keys.ARROW_RIGHT) {\n          var nextActiveIndex = _this.getNextActiveIndex(event.which === Keys.ARROW_RIGHT ? 1 : -1);\n\n          if (nextActiveIndex !== activeIndex) {\n            event.stopPropagation();\n            activeIndexToEmit = nextActiveIndex;\n\n            _this.setState({\n              activeIndex: nextActiveIndex\n            });\n          }\n        } else if (event.which === Keys.BACKSPACE) {\n          _this.handleBackspaceToRemove(event);\n        } else if (event.which === Keys.DELETE) {\n          _this.handleDeleteToRemove(event);\n        }\n      }\n\n      _this.invokeKeyPressCallback(\"onKeyDown\", event, activeIndexToEmit);\n    };\n\n    _this.handleInputKeyUp = function (event) {\n      _this.invokeKeyPressCallback(\"onKeyUp\", event, _this.state.activeIndex);\n    };\n\n    _this.handleInputPaste = function (event) {\n      var separator = _this.props.separator;\n      var value = event.clipboardData.getData(\"text\");\n\n      if (!_this.props.addOnPaste || value.length === 0) {\n        return;\n      } // special case as a UX nicety: if the user pasted only one value with no delimiters in it, leave that value in\n      // the input field so that the user can refine it before converting it to a tag manually.\n\n\n      if (separator === false || value.split(separator).length === 1) {\n        return;\n      }\n\n      event.preventDefault();\n\n      _this.addTags(value, \"paste\");\n    };\n\n    _this.handleRemoveTag = function (event) {\n      // using data attribute to simplify callback logic -- one handler for all children\n      var index = +event.currentTarget.parentElement.getAttribute(\"data-tag-index\");\n\n      _this.removeIndexFromValues(index);\n    };\n\n    return _this;\n  }\n\n  TagInput.getDerivedStateFromProps = function (props, state) {\n    if (props.inputValue !== state.prevInputValueProp) {\n      return {\n        inputValue: props.inputValue,\n        prevInputValueProp: props.inputValue\n      };\n    }\n\n    return null;\n  };\n\n  TagInput.prototype.render = function () {\n    var _a;\n\n    var _b = this.props,\n        className = _b.className,\n        disabled = _b.disabled,\n        fill = _b.fill,\n        inputProps = _b.inputProps,\n        intent = _b.intent,\n        large = _b.large,\n        leftIcon = _b.leftIcon,\n        placeholder = _b.placeholder,\n        values = _b.values;\n    var classes = classNames(Classes.INPUT, Classes.TAG_INPUT, (_a = {}, _a[Classes.ACTIVE] = this.state.isInputFocused, _a[Classes.DISABLED] = disabled, _a[Classes.FILL] = fill, _a[Classes.LARGE] = large, _a), Classes.intentClass(intent), className);\n    var isLarge = classes.indexOf(Classes.LARGE) > NONE; // use placeholder prop only if it's defined and values list is empty or contains only falsy values\n\n    var isSomeValueDefined = values.some(function (val) {\n      return !!val;\n    });\n    var resolvedPlaceholder = placeholder == null || isSomeValueDefined ? inputProps.placeholder : placeholder;\n    return React.createElement(\"div\", {\n      className: classes,\n      onBlur: this.handleContainerBlur,\n      onClick: this.handleContainerClick\n    }, React.createElement(Icon, {\n      className: Classes.TAG_INPUT_ICON,\n      icon: leftIcon,\n      iconSize: isLarge ? Icon.SIZE_LARGE : Icon.SIZE_STANDARD\n    }), React.createElement(\"div\", {\n      className: Classes.TAG_INPUT_VALUES\n    }, values.map(this.maybeRenderTag), this.props.children, React.createElement(\"input\", __assign({\n      value: this.state.inputValue\n    }, inputProps, {\n      onFocus: this.handleInputFocus,\n      onChange: this.handleInputChange,\n      onKeyDown: this.handleInputKeyDown,\n      onKeyUp: this.handleInputKeyUp,\n      onPaste: this.handleInputPaste,\n      placeholder: resolvedPlaceholder,\n      ref: this.refHandlers.input,\n      className: classNames(Classes.INPUT_GHOST, inputProps.className),\n      disabled: disabled\n    }))), this.props.rightElement);\n  };\n\n  TagInput.prototype.getNextActiveIndex = function (direction) {\n    var activeIndex = this.state.activeIndex;\n\n    if (activeIndex === NONE) {\n      // nothing active & moving left: select last defined value. otherwise select nothing.\n      return direction < 0 ? this.findNextIndex(this.props.values.length, -1) : NONE;\n    } else {\n      // otherwise, move in direction and clamp to bounds.\n      // note that upper bound allows going one beyond last item\n      // so focus can move off the right end, into the text input.\n      return this.findNextIndex(activeIndex, direction);\n    }\n  };\n\n  TagInput.prototype.findNextIndex = function (startIndex, direction) {\n    var values = this.props.values;\n    var index = startIndex + direction;\n\n    while (index > 0 && index < values.length && !values[index]) {\n      index += direction;\n    }\n\n    return Utils.clamp(index, 0, values.length);\n  };\n  /**\n   * Splits inputValue on separator prop,\n   * trims whitespace from each new value,\n   * and ignores empty values.\n   */\n\n\n  TagInput.prototype.getValues = function (inputValue) {\n    var separator = this.props.separator; // NOTE: split() typings define two overrides for string and RegExp.\n    // this does not play well with our union prop type, so we'll just declare it as a valid type.\n\n    return (separator === false ? [inputValue] : inputValue.split(separator)).map(function (val) {\n      return val.trim();\n    }).filter(function (val) {\n      return val.length > 0;\n    });\n  };\n\n  TagInput.prototype.handleBackspaceToRemove = function (event) {\n    var previousActiveIndex = this.state.activeIndex; // always move leftward one item (this will focus last item if nothing is focused)\n\n    this.setState({\n      activeIndex: this.getNextActiveIndex(-1)\n    }); // delete item if there was a previous valid selection (ignore first backspace to focus last item)\n\n    if (this.isValidIndex(previousActiveIndex)) {\n      event.stopPropagation();\n      this.removeIndexFromValues(previousActiveIndex);\n    }\n  };\n\n  TagInput.prototype.handleDeleteToRemove = function (event) {\n    var activeIndex = this.state.activeIndex;\n\n    if (this.isValidIndex(activeIndex)) {\n      event.stopPropagation();\n      this.removeIndexFromValues(activeIndex);\n    }\n  };\n  /** Remove the item at the given index by invoking `onRemove` and `onChange` accordingly. */\n\n\n  TagInput.prototype.removeIndexFromValues = function (index) {\n    var _a = this.props,\n        onChange = _a.onChange,\n        onRemove = _a.onRemove,\n        values = _a.values;\n    Utils.safeInvoke(onRemove, values[index], index);\n\n    if (Utils.isFunction(onChange)) {\n      onChange(values.filter(function (_, i) {\n        return i !== index;\n      }));\n    }\n  };\n\n  TagInput.prototype.invokeKeyPressCallback = function (propCallbackName, event, activeIndex) {\n    Utils.safeInvoke(this.props[propCallbackName], event, activeIndex === NONE ? undefined : activeIndex);\n    Utils.safeInvoke(this.props.inputProps[propCallbackName], event);\n  };\n  /** Returns whether the given index represents a valid item in `this.props.values`. */\n\n\n  TagInput.prototype.isValidIndex = function (index) {\n    return index !== NONE && index < this.props.values.length;\n  };\n\n  TagInput.displayName = DISPLAYNAME_PREFIX + \".TagInput\";\n  TagInput.defaultProps = {\n    addOnBlur: false,\n    addOnPaste: true,\n    inputProps: {},\n    separator: /[,\\n\\r]/,\n    tagProps: {}\n  };\n  TagInput = __decorate([polyfill], TagInput);\n  return TagInput;\n}(AbstractPureComponent2);\n\nexport { TagInput };","map":{"version":3,"sources":["../../../../src/components/tag-input/tagInput.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends, __spreadArrays } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, Classes, Keys, Utils } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { Icon } from \"../icon/icon\";\nimport { Tag } from \"../tag/tag\";\n/** special value for absence of active tag */\nvar NONE = -1;\nvar TagInput = /** @class */ (function (_super) {\n    __extends(TagInput, _super);\n    function TagInput() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            activeIndex: NONE,\n            inputValue: _this.props.inputValue || \"\",\n            isInputFocused: false,\n        };\n        _this.refHandlers = {\n            input: function (ref) {\n                _this.inputElement = ref;\n                Utils.safeInvoke(_this.props.inputRef, ref);\n            },\n        };\n        _this.addTags = function (value, method) {\n            if (method === void 0) { method = \"default\"; }\n            var _a = _this.props, inputValue = _a.inputValue, onAdd = _a.onAdd, onChange = _a.onChange, values = _a.values;\n            var newValues = _this.getValues(value);\n            var shouldClearInput = Utils.safeInvoke(onAdd, newValues, method) !== false && inputValue === undefined;\n            // avoid a potentially expensive computation if this prop is omitted\n            if (Utils.isFunction(onChange)) {\n                shouldClearInput = onChange(__spreadArrays(values, newValues)) !== false && shouldClearInput;\n            }\n            // only explicit return false cancels text clearing\n            if (shouldClearInput) {\n                _this.setState({ inputValue: \"\" });\n            }\n        };\n        _this.maybeRenderTag = function (tag, index) {\n            if (!tag) {\n                return null;\n            }\n            var _a = _this.props, large = _a.large, tagProps = _a.tagProps;\n            var props = Utils.isFunction(tagProps) ? tagProps(tag, index) : tagProps;\n            return (React.createElement(Tag, __assign({ active: index === _this.state.activeIndex, \"data-tag-index\": index, key: tag + \"__\" + index, large: large, onRemove: _this.props.disabled ? null : _this.handleRemoveTag }, props), tag));\n        };\n        _this.handleContainerClick = function () {\n            if (_this.inputElement != null) {\n                _this.inputElement.focus();\n            }\n        };\n        _this.handleContainerBlur = function (_a) {\n            var currentTarget = _a.currentTarget;\n            requestAnimationFrame(function () {\n                // we only care if the blur event is leaving the container.\n                // defer this check using rAF so activeElement will have updated.\n                if (!currentTarget.contains(document.activeElement)) {\n                    if (_this.props.addOnBlur && _this.state.inputValue !== undefined && _this.state.inputValue.length > 0) {\n                        _this.addTags(_this.state.inputValue, \"blur\");\n                    }\n                    _this.setState({ activeIndex: NONE, isInputFocused: false });\n                }\n            });\n        };\n        _this.handleInputFocus = function (event) {\n            _this.setState({ isInputFocused: true });\n            Utils.safeInvoke(_this.props.inputProps.onFocus, event);\n        };\n        _this.handleInputChange = function (event) {\n            _this.setState({ activeIndex: NONE, inputValue: event.currentTarget.value });\n            Utils.safeInvoke(_this.props.onInputChange, event);\n            Utils.safeInvoke(_this.props.inputProps.onChange, event);\n        };\n        _this.handleInputKeyDown = function (event) {\n            var _a = event.currentTarget, selectionEnd = _a.selectionEnd, value = _a.value;\n            var activeIndex = _this.state.activeIndex;\n            var activeIndexToEmit = activeIndex;\n            if (event.which === Keys.ENTER && value.length > 0) {\n                _this.addTags(value, \"default\");\n            }\n            else if (selectionEnd === 0 && _this.props.values.length > 0) {\n                // cursor at beginning of input allows interaction with tags.\n                // use selectionEnd to verify cursor position and no text selection.\n                if (event.which === Keys.ARROW_LEFT || event.which === Keys.ARROW_RIGHT) {\n                    var nextActiveIndex = _this.getNextActiveIndex(event.which === Keys.ARROW_RIGHT ? 1 : -1);\n                    if (nextActiveIndex !== activeIndex) {\n                        event.stopPropagation();\n                        activeIndexToEmit = nextActiveIndex;\n                        _this.setState({ activeIndex: nextActiveIndex });\n                    }\n                }\n                else if (event.which === Keys.BACKSPACE) {\n                    _this.handleBackspaceToRemove(event);\n                }\n                else if (event.which === Keys.DELETE) {\n                    _this.handleDeleteToRemove(event);\n                }\n            }\n            _this.invokeKeyPressCallback(\"onKeyDown\", event, activeIndexToEmit);\n        };\n        _this.handleInputKeyUp = function (event) {\n            _this.invokeKeyPressCallback(\"onKeyUp\", event, _this.state.activeIndex);\n        };\n        _this.handleInputPaste = function (event) {\n            var separator = _this.props.separator;\n            var value = event.clipboardData.getData(\"text\");\n            if (!_this.props.addOnPaste || value.length === 0) {\n                return;\n            }\n            // special case as a UX nicety: if the user pasted only one value with no delimiters in it, leave that value in\n            // the input field so that the user can refine it before converting it to a tag manually.\n            if (separator === false || value.split(separator).length === 1) {\n                return;\n            }\n            event.preventDefault();\n            _this.addTags(value, \"paste\");\n        };\n        _this.handleRemoveTag = function (event) {\n            // using data attribute to simplify callback logic -- one handler for all children\n            var index = +event.currentTarget.parentElement.getAttribute(\"data-tag-index\");\n            _this.removeIndexFromValues(index);\n        };\n        return _this;\n    }\n    TagInput.getDerivedStateFromProps = function (props, state) {\n        if (props.inputValue !== state.prevInputValueProp) {\n            return {\n                inputValue: props.inputValue,\n                prevInputValueProp: props.inputValue,\n            };\n        }\n        return null;\n    };\n    TagInput.prototype.render = function () {\n        var _a;\n        var _b = this.props, className = _b.className, disabled = _b.disabled, fill = _b.fill, inputProps = _b.inputProps, intent = _b.intent, large = _b.large, leftIcon = _b.leftIcon, placeholder = _b.placeholder, values = _b.values;\n        var classes = classNames(Classes.INPUT, Classes.TAG_INPUT, (_a = {},\n            _a[Classes.ACTIVE] = this.state.isInputFocused,\n            _a[Classes.DISABLED] = disabled,\n            _a[Classes.FILL] = fill,\n            _a[Classes.LARGE] = large,\n            _a), Classes.intentClass(intent), className);\n        var isLarge = classes.indexOf(Classes.LARGE) > NONE;\n        // use placeholder prop only if it's defined and values list is empty or contains only falsy values\n        var isSomeValueDefined = values.some(function (val) { return !!val; });\n        var resolvedPlaceholder = placeholder == null || isSomeValueDefined ? inputProps.placeholder : placeholder;\n        return (React.createElement(\"div\", { className: classes, onBlur: this.handleContainerBlur, onClick: this.handleContainerClick },\n            React.createElement(Icon, { className: Classes.TAG_INPUT_ICON, icon: leftIcon, iconSize: isLarge ? Icon.SIZE_LARGE : Icon.SIZE_STANDARD }),\n            React.createElement(\"div\", { className: Classes.TAG_INPUT_VALUES },\n                values.map(this.maybeRenderTag),\n                this.props.children,\n                React.createElement(\"input\", __assign({ value: this.state.inputValue }, inputProps, { onFocus: this.handleInputFocus, onChange: this.handleInputChange, onKeyDown: this.handleInputKeyDown, onKeyUp: this.handleInputKeyUp, onPaste: this.handleInputPaste, placeholder: resolvedPlaceholder, ref: this.refHandlers.input, className: classNames(Classes.INPUT_GHOST, inputProps.className), disabled: disabled }))),\n            this.props.rightElement));\n    };\n    TagInput.prototype.getNextActiveIndex = function (direction) {\n        var activeIndex = this.state.activeIndex;\n        if (activeIndex === NONE) {\n            // nothing active & moving left: select last defined value. otherwise select nothing.\n            return direction < 0 ? this.findNextIndex(this.props.values.length, -1) : NONE;\n        }\n        else {\n            // otherwise, move in direction and clamp to bounds.\n            // note that upper bound allows going one beyond last item\n            // so focus can move off the right end, into the text input.\n            return this.findNextIndex(activeIndex, direction);\n        }\n    };\n    TagInput.prototype.findNextIndex = function (startIndex, direction) {\n        var values = this.props.values;\n        var index = startIndex + direction;\n        while (index > 0 && index < values.length && !values[index]) {\n            index += direction;\n        }\n        return Utils.clamp(index, 0, values.length);\n    };\n    /**\n     * Splits inputValue on separator prop,\n     * trims whitespace from each new value,\n     * and ignores empty values.\n     */\n    TagInput.prototype.getValues = function (inputValue) {\n        var separator = this.props.separator;\n        // NOTE: split() typings define two overrides for string and RegExp.\n        // this does not play well with our union prop type, so we'll just declare it as a valid type.\n        return (separator === false ? [inputValue] : inputValue.split(separator))\n            .map(function (val) { return val.trim(); })\n            .filter(function (val) { return val.length > 0; });\n    };\n    TagInput.prototype.handleBackspaceToRemove = function (event) {\n        var previousActiveIndex = this.state.activeIndex;\n        // always move leftward one item (this will focus last item if nothing is focused)\n        this.setState({ activeIndex: this.getNextActiveIndex(-1) });\n        // delete item if there was a previous valid selection (ignore first backspace to focus last item)\n        if (this.isValidIndex(previousActiveIndex)) {\n            event.stopPropagation();\n            this.removeIndexFromValues(previousActiveIndex);\n        }\n    };\n    TagInput.prototype.handleDeleteToRemove = function (event) {\n        var activeIndex = this.state.activeIndex;\n        if (this.isValidIndex(activeIndex)) {\n            event.stopPropagation();\n            this.removeIndexFromValues(activeIndex);\n        }\n    };\n    /** Remove the item at the given index by invoking `onRemove` and `onChange` accordingly. */\n    TagInput.prototype.removeIndexFromValues = function (index) {\n        var _a = this.props, onChange = _a.onChange, onRemove = _a.onRemove, values = _a.values;\n        Utils.safeInvoke(onRemove, values[index], index);\n        if (Utils.isFunction(onChange)) {\n            onChange(values.filter(function (_, i) { return i !== index; }));\n        }\n    };\n    TagInput.prototype.invokeKeyPressCallback = function (propCallbackName, event, activeIndex) {\n        Utils.safeInvoke(this.props[propCallbackName], event, activeIndex === NONE ? undefined : activeIndex);\n        Utils.safeInvoke(this.props.inputProps[propCallbackName], event);\n    };\n    /** Returns whether the given index represents a valid item in `this.props.values`. */\n    TagInput.prototype.isValidIndex = function (index) {\n        return index !== NONE && index < this.props.values.length;\n    };\n    TagInput.displayName = DISPLAYNAME_PREFIX + \".TagInput\";\n    TagInput.defaultProps = {\n        addOnBlur: false,\n        addOnPaste: true,\n        inputProps: {},\n        separator: /[,\\n\\r]/,\n        tagProps: {},\n    };\n    TagInput = __decorate([\n        polyfill\n    ], TagInput);\n    return TagInput;\n}(AbstractPureComponent2));\nexport { TagInput };\n//# sourceMappingURL=tagInput.js.map"]},"metadata":{},"sourceType":"module"}